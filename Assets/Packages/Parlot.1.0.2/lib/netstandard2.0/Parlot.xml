<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Parlot</name>
    </assembly>
    <members>
        <member name="T:FastExpressionCompiler.CompilerFlags">
            <summary>The flags for the compiler</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.Default">
            <summary>The default flags: Invocation lambda is inlined, no debug info</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.NoInvocationLambdaInlining">
            <summary>Prevents the inlining of the lambda in the Invocation expression to optimize for the multiple same lambda compiled once</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.EnableDelegateDebugInfo">
            <summary>Adds the Expression, ExpressionString, and CSharpString to the delegate closure for the debugging inspection</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.ThrowOnNotSupportedExpression">
            <summary>When the flag is set then instead of the returning `null` the specific exception is thrown*346</summary>
        </member>
        <member name="T:FastExpressionCompiler.NotSupportedExpressionException">
            <summary>FEC Not Supported exception</summary>
        </member>
        <member name="F:FastExpressionCompiler.NotSupportedExpressionException.Reason">
            <summary>The reason</summary>
        </member>
        <member name="M:FastExpressionCompiler.NotSupportedExpressionException.#ctor(FastExpressionCompiler.ExpressionCompiler.Result)">
            <summary>Constructor</summary>
        </member>
        <member name="M:FastExpressionCompiler.NotSupportedExpressionException.#ctor(FastExpressionCompiler.ExpressionCompiler.Result,System.String)">
            <summary>Constructor</summary>
        </member>
        <member name="T:FastExpressionCompiler.IDelegateDebugInfo">
            <summary>The interface is implemented by the compiled delegate Target if `CompilerFlags.EnableDelegateDebugInfo` is set.</summary>
        </member>
        <member name="P:FastExpressionCompiler.IDelegateDebugInfo.Expression">
            <summary>The lambda expression object that was compiled to the delegate</summary>
        </member>
        <member name="P:FastExpressionCompiler.IDelegateDebugInfo.ExpressionString">
            <summary>The lambda expression construction syntax C# code</summary>
        </member>
        <member name="P:FastExpressionCompiler.IDelegateDebugInfo.CSharpString">
            <summary>The equivalent C# code of the lambda expression</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler">
            <summary>Compiles expression to delegate ~20 times faster than Expression.Compile.
            Partial to extend with your things when used as source file.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.LambdaExpression,System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFastToIL(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.ILGenerator,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles a static method to the passed IL Generator.
            Could be used as alternative for `CompileToMethod` like this <code><![CDATA[funcExpr.CompileFastToIL(methodBuilder.GetILGenerator())]]></code>.
            Check `IssueTests.Issue179_Add_something_like_LambdaExpression_CompileToMethod.cs` for example.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast(System.Linq.Expressions.LambdaExpression,System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileSys``1(System.Linq.Expressions.Expression{``0})">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileSys(System.Linq.Expressions.LambdaExpression)">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{``0},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``6(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``7(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast(System.Linq.Expressions.Expression{System.Action},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{System.Action{``0}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``2(System.Linq.Expressions.Expression{System.Action{``0,``1}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``3(System.Linq.Expressions.Expression{System.Action{``0,``1,``2}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``4(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``5(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``6(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompile``1(System.Linq.Expressions.LambdaExpression,FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/></summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompileWithPreCreatedClosure``1(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ConstantExpression[])">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
            with the provided closure object and constant expressions (or lack there of) -
            Constant expression should be the in order of Fields in closure object!
            Note 1: Use it on your own risk - FEC won't verify the expression is compile-able with passed closure, it is up to you!
            Note 2: The expression with NESTED LAMBDA IS NOT SUPPORTED!
            Note 3: `Label` and `GoTo` are not supported in this case, because they need first round to collect out-of-order labels</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompileWithPreCreatedClosure``1(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ConstantExpression[],FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
            with the provided closure object and constant expressions (or lack there of)</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompileWithoutClosure``1(System.Linq.Expressions.LambdaExpression,FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to compile expression to "static" delegate, skipping the step of collecting the closure object.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo">
            <summary>Collects the lambda info for the compilation</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.Lambda">
            <summary>Compiled lambda</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NestedLambdas">
            <summary>The nested lambdas and their info</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.LambdaExpression">
            <summary>The lambda expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NonPassedParameters">
            <summary>Parameters not passed through lambda parameter list But used inside lambda body.
            The top expression should Not contain not passed parameters.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.LambdaVarIndex">
            <summary>Index of the compiled lambda in the parent lambda closure array</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NonPassedParamsVarIndex">
            <summary>Index of the variable which store the non-passed variables array before passing it to the closure constructor.
            It used to assign the closed variables from the outside of the nested lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.GetLambdaType">
            <summary>Returns the type of lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.HasTheSameLambdaExpression(System.Linq.Expressions.LambdaExpression)">
            <summary>Compares 2 lambda expressions for equality</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.ClosureInfo">
            Track the info required to build a closure object + some context information not directly related to closure.
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.LastEmitIsAddress">
            <summary>Tracks that the last emit was an address</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo._varInBlockMap">
            <summary>Tracks the use of the variables in the blocks stack per variable, 
            (uint) contains (ushort) BlockIndex in the upper bits and (ushort) VarIndex in the lower bits.
            to determine if variable is the local variable and in what block it's defined</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.InlinedLambdaInvocationMap">
            The map of inlined invocations collected in TryCollect and then used in TryEmit
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.ArgsContainingComplexExpression">
            New or Call expressions containing the complex expression, e.g. inlined Lambda Invoke or Try with Finally
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.LambdaInvokeStackLabels">
            The stack for the lambda invocation and the labels bound to them
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.CurrentInlinedLambdaInvokeIndex">
            This is required because we have the return from the nested lambda expression,
            and when inlined in the parent lambda it is no longer the return but just a jump to the label.
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.Constants">
            Constant expressions to find an index (by reference) of constant expression from compiled expression.
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.ConstantUsageThenVarIndex">
            Constant usage count and variable index.
            It is a separate collection from the Constants because we directly convert later into the closure array
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.NonPassedParameters">
            <summary>Parameters not passed through lambda parameter list But used inside lambda body.
            The top expression should Not contain not passed parameters.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.NestedLambdas">
            <summary>The nested lambdas and their info</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.#ctor(FastExpressionCompiler.ExpressionCompiler.ClosureStatus)">
            <summary>Populates the info</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.#ctor(FastExpressionCompiler.ExpressionCompiler.ClosureStatus,System.Object[])">
            <summary>Populates info directly with provided closure object and constants.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.PushBlockWithVars(System.Linq.Expressions.ParameterExpression)">
            Local variable index is not known in the collecting phase when we only need to decide if ParameterExpression is an actual parameter or variable
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.IsClosureBoundConstant(System.Object,System.Type)">
            Helps to identify constants as the one to be put into the Closure
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_NewArrayInit_MultidimensionalArray">
            <summary>Multi-dimensional array initializer is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Quote">
            <summary>Quote is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Dynamic">
            <summary>Dynamic is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_RuntimeVariables">
            <summary>RuntimeVariables is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_MemberInit_MemberBinding">
            <summary>MemberInit MemberBinding is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_MemberInit_ListBinding">
            <summary>MemberInit ListBinding is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Try_GotoReturnToTheFollowupLabel">
            <summary>Goto of the Return kind from the TryCatch is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Assign_Target">
            <summary>Not supported assignment target</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_TypeEqual">
            <summary>TypeEqual is not supported </summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_ExceptionCatchFilter">
            <summary>`when` in catch is not supported yet</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCollectBoundConstants(FastExpressionCompiler.ExpressionCompiler.ClosureInfo@,System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo,FastExpressionCompiler.ImTools.SmallList{FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo}@,FastExpressionCompiler.CompilerFlags)">
            <summary>Wraps the call to `TryCollectInfo` for the compatibility and provide the root place to check the returned error code.
            Important: The method collects the info from the nested lambdas up-front and de-duplicates the lambdas as well.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCollectInfo(FastExpressionCompiler.ExpressionCompiler.ClosureInfo@,System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo,FastExpressionCompiler.ImTools.SmallList{FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo}@,FastExpressionCompiler.CompilerFlags)">
            <summary>Collects the information about closure constants, nested lambdas, non-passed parameters, goto labels and variables in blocks.
            Returns `OK` result if everything is fine and other result for error.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryGetDebugInfo``1(``0)">
            <summary>Return IDelegateDebugInfo if the delegate is fast compiled with `CompilerFlags.EnableDelegateDebugInfo` flag</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.ParentFlags">
            The minimal context-aware flags set by parent
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Empty">
            Default is no flags
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.IgnoreResult">
            The result of expression is ignored and maybe popped out
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Call">
            Some parent is the call expression
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.MemberAccess">
            Any Parent Expression is a MemberExpression
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Arithmetic">
            Some arithmetic operation
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Coalesce">
            Subject
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.InstanceAccess">
            Expression with instance object (method call or member access or array access)
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.DupIt">
            Subject
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.TryCatch">
            Subject
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.InstanceCall">
            Combination`of InstanceAccess and Call
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Ctor">
            Constructor
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.CtorCall">
            Constructor call
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.IndexAccess">
            Indexer
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.InlinedLambdaInvoke">
            Invoking the inlined lambda (the default System.Expression behavior)
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.AssignmentLeftValue">
            <summary>Indicate if the part AT LEAST participates in the assignment on the left side, 
            it may also participate in the right side, e.g. ++x.Bar</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.AssignmentRightValue">
            <summary>Indicates the ONLY right value of assignment, e.g. `p` in `foo.Bar += p` </summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.AssignmentByRef">
            <summary>Assigning the ref of the right value to the left, e.g. in `var a = ref b[1]` we are passing this flag for the `ref b[1]`</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.LambdaCall">
            <summary>Indicates the root lambda call</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.ReturnByRef">
            <summary>ReturnByRef</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.BlockResult">
            <summary>The block result</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor">
            <summary>Supports emitting of selected expressions, e.g. lambdaExpr are not supported yet.
            When emitter find not supported expression it will return false from <see cref="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.TryEmit(System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},System.Reflection.Emit.ILGenerator,FastExpressionCompiler.ExpressionCompiler.ClosureInfo@,FastExpressionCompiler.CompilerFlags,FastExpressionCompiler.ExpressionCompiler.ParentFlags,System.Int32)"/>, so I could fallback
            to normal and slow Expression.Compile.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitMethodCallOrVirtualCall(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            Get the advantage of the optimized specialized EmitCall method
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitMethodCallCheckForNull(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            Same as EmitMethodCall which checks the method for null first, and returns false if it is null. 
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitMethodCallOrVirtualCallCheckForNull(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            Same as EmitMethodCallOrVirtualCall which checks the method for null first, and returns false if it is null. 
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitLoadConstantInt(System.Reflection.Emit.ILGenerator,System.Int32)">
            Efficiently emit the int constant
        </member>
        <member name="T:FastExpressionCompiler.ILGeneratorHacks">
            <summary>Reflecting the internal methods to access the more performant for defining the local variable</summary>
        </member>
        <member name="M:FastExpressionCompiler.ILGeneratorHacks.GetNextLocalVarIndex(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>Efficiently returns the next variable index, hopefully without unnecessary allocations.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToExpressionPrinter.ToExpressionString(System.Linq.Expressions.Expression,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>
            Prints the expression in its constructing syntax - 
            helpful to get the expression from the debug session and put into it the code for the test.
            </summary>
        </member>
        <member name="M:FastExpressionCompiler.ToExpressionPrinter.ToExpressionString(System.Linq.Expressions.Expression,System.Collections.Generic.List{System.Linq.Expressions.ParameterExpression}@,System.Collections.Generic.List{System.Linq.Expressions.Expression}@,System.Collections.Generic.List{System.Linq.Expressions.LabelTarget}@,System.Boolean,System.Func{System.Type,System.String,System.String},System.Int32,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>
            Prints the expression in its constructing syntax - 
            helpful to get the expression from the debug session and put into it the code for the test.
            In addition, returns the gathered expressions, parameters ad labels. 
            </summary>
        </member>
        <member name="T:FastExpressionCompiler.ToCSharpPrinter">
            <summary>Converts the expression into the valid C# code representation</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToCSharpPrinter.ToCSharpString(System.Linq.Expressions.Expression)">
            <summary>Tries hard to convert the expression into the valid C# code</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToCSharpPrinter.ToCSharpString(System.Linq.Expressions.Expression,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>Tries hard to convert the expression into the valid C# code</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToCSharpPrinter.ToCSharpString(System.Linq.Expressions.Expression,System.Text.StringBuilder,System.Int32,System.Boolean,System.Func{System.Type,System.String,System.String},System.Int32,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>Tries hard to convert the expression into the valid C# code</summary>
        </member>
        <member name="T:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn">
            <summary>Indicates the expression container</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.ParensByDefault">
            <summary>Prefers the parens by default</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.IfTest">
            <summary>The test part of the If expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.Block">
            <summary>The `if (test)` part</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.LambdaBody">
            <summary>The lambda</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.Return">
            <summary>Return expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.AvoidParens">
            <summary>Instructs the client code to avoid parenthesis for the generated C# code, e.g. if we have as single argument in a method</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.Instance">
            <summary>The instance when calling the instance method or accessing the instance member</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.Type,System.Boolean,System.Func{System.Type,System.String,System.String},System.Boolean)">
            <summary>Converts the <paramref name="type"/> into the proper C# representation.</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.Boolean)">
            <summary>Prints valid C# Boolean</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.String)">
            <summary>Prints valid C# String escaping the things</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToEnumValueCode(System.Type,System.Object,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints valid C# Enum literal</summary>
        </member>
        <member name="T:FastExpressionCompiler.CodePrinter.ObjectToCode">
            <summary>Custom handler for output the object in valid C#. Note, the `printGenericTypeArgs` is excluded because it cannot be a open-generic object.
            This handler is also used to allow user to fully control a Constant expression output</summary>
        </member>
        <member name="F:FastExpressionCompiler.CodePrinter.DefaultNotRecognizedToCode">
            <summary>Outputs the `default(Type)` for the unknown constant with the comment message</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCommaSeparatedCode(System.Collections.IEnumerable,FastExpressionCompiler.CodePrinter.ObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints many code items as the array initializer.</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToArrayInitializerCode(System.Collections.IEnumerable,System.Type,FastExpressionCompiler.CodePrinter.ObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints many code items as array initializer.</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.Object,FastExpressionCompiler.CodePrinter.ObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>
            Prints a valid C# for known <paramref name="x"/>,
            otherwise uses passed <paramref name="notRecognizedToCode"/> or falls back to `ToString()`.
            </summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.CountLambdas(System.String)">
            <summary>Helper method to find the number of lambdas in the C# `code` string</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList`1">
            <summary>Wrapper for the array and count</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList`1.Items">
            <summary>Array of items</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList`1.Count">
            <summary>The count of used items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`1.#ctor(`0[],System.Int32)">
            <summary>Creating this stuff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`1.#ctor(`0[])">
            <summary>Creates the wrapper out of the items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`1.Pop">
            <summary>Popping candy</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList">
            <summary>SmallList module he-he</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AddDefaultToNotNullItemsAndGetRef``1(``0[]@,System.Int32)">
            <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`! 
            `items` should be not null</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AddDefaultAndGetRef``1(``0[]@,System.Int32,System.Int32)">
            <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`, `items` may be null</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.SmallList{``0}@,System.Int32)">
            <summary>Returns surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.Add``1(FastExpressionCompiler.ImTools.SmallList{``0}@,System.Int32)">
            <summary>Appends the new default item to the list and returns ref to it for write or read</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.Add``1(FastExpressionCompiler.ImTools.SmallList{``0}@,``0@,System.Int32)">
            <summary>Appends the new item to the list</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(``0[],``0@,System.Int32,System.Int32,``1,System.Int32)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(FastExpressionCompiler.ImTools.SmallList{``0}@,``0,``1)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetIndexOrAdd``2(FastExpressionCompiler.ImTools.SmallList{``0}@,``0@,``1)">
            <summary>Returns the ref of the found item or appends the item to the end of the list, and returns ref to it</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.SmallList4{``0}@,System.Int32)">
            <summary>Returns surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetLastSurePresentItem``1(FastExpressionCompiler.ImTools.SmallList4{``0}@)">
            <summary>Returns last present item ref, assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.NotFound``1(FastExpressionCompiler.ImTools.SmallList4{``0}@)">
            <summary>Returns the ref to tombstone indicating the missing item.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AddDefaultAndGetRef``1(FastExpressionCompiler.ImTools.SmallList4{``0}@)">
            <summary>Appends the default item to the end of the list and returns the reference to it.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(FastExpressionCompiler.ImTools.SmallList4{``0}@,``0,``1)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetIndexOrAdd``2(FastExpressionCompiler.ImTools.SmallList4{``0}@,``0@,``1)">
            <summary>Returns the ref of the found item or appends the item to the end of the list, and returns ref to it</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.SmallList2{``0}@,System.Int32)">
            <summary>Returns surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetLastSurePresentItem``1(FastExpressionCompiler.ImTools.SmallList2{``0}@)">
            <summary>Returns last present item ref, assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.NotFound``1(FastExpressionCompiler.ImTools.SmallList2{``0}@)">
            <summary>Returns the ref to tombstone indicating the missing item.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AddDefaultAndGetRef``1(FastExpressionCompiler.ImTools.SmallList2{``0}@)">
            <summary>Appends the default item to the end of the list and returns the reference to it.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(FastExpressionCompiler.ImTools.SmallList2{``0}@,``0,``1)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetIndexOrAdd``2(FastExpressionCompiler.ImTools.SmallList2{``0}@,``0,``1)">
            <summary>Returns the ref of the found item or appends the item to the end of the list, and returns ref to it</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList4`1">
            <summary>List with the number of first items (4) stored inside its struct and the rest in the growable array.
            Supports addition and removal (remove is without resize) only at the end of the list, aka Stack behavior</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList4`1.StackCapacity">
            <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList4`1.Count">
            <summary>Gets the number of items in the list</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Populate1(`0)">
            <summary>Populate with one item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Populate2(`0,`0)">
            <summary>Populate with two items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Populate3(`0,`0,`0)">
            <summary>Populate with 3 items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Populate4(`0,`0,`0,`0)">
            <summary>Populate with 4 items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Populate(`0,`0,`0,`0,`0[])">
            <summary>Populate with more than two items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Populate``1(``0)">
            <summary>Populate with arbitrary items</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList4`1.Item(System.Int32)">
            <summary>Returns surely present item by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Add(`0@)">
            <summary>Adds the item to the end of the list aka the Stack.Push</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.AddDefault">
            <summary>Adds the default item to the end of the list aka the Stack.Push default</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.RemoveLastSurePresentItem">
            <summary>Removes the last item from the list aka the Stack Pop. Assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.ToArray">
            <summary>Copy items to new the array</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList2`1">
            <summary>List with the number of first items (2) stored inside its struct and the rest in the growable array.
            Supports addition and removal (remove is without resize) only at the end of the list, aka Stack behavior</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList2`1.StackCapacity">
            <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.InitCount(System.Int32)">
            <summary>Good stuff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Populate1(`0)">
            <summary>Populate with one item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Populate2(`0,`0)">
            <summary>Populate with two items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Populate(`0,`0,`0[])">
            <summary>Populate with more than two items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Populate``1(``0)">
            <summary>Populate with arbitrary items</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList2`1.Count">
            <summary>Gets the number of items in the list</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList2`1.Item(System.Int32)">
            <summary>Returns surely present item by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Add(`0@)">
            <summary>Adds the item to the end of the list aka the Stack.Push</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.AddDefault">
            <summary>Adds the default item to the end of the list aka the Stack.Push default</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.RemoveLastSurePresentItem">
            <summary>Removes the last item from the list aka the Stack Pop. Assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.ToArray">
            <summary>Copy items to new the array</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.Hasher">
            <summary>Combines the hashes of 2 keys</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.Hasher.Combine(System.Int32,System.Int32)">
            <summary>Combines the hashes of 2 keys</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.IEq`1">
            <summary>Configures removed key tombstone, equality and hash function for the FHashMap</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IEq`1.GetTombstone">
            <summary>Defines the value of the key indicating the removed entry</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IEq`1.Equals(`0,`0)">
            <summary>Equals keys</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IEq`1.GetHashCode(`0)">
            <summary>Calculates and returns the hash of the key</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.DefaultEq`1">
            <summary>Default comparer using the `object.GetHashCode` and `object.Equals` overloads</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.DefaultEq`1.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.DefaultEq`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.DefaultEq`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.RefEq`1">
            <summary>Uses the `object.GetHashCode` and `object.ReferenceEquals`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`1.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.RefEq`2">
            <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`2.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`2.Equals(System.ValueTuple{`0,`1},System.ValueTuple{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`2.GetHashCode(System.ValueTuple{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.RefEq`3">
            <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`3.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`3.Equals(System.ValueTuple{`0,`1,`2},System.ValueTuple{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`3.GetHashCode(System.ValueTuple{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4">
            <summary>Configuration and the tools for the FHashMap map data structure</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallMap4.MaxProbeBits">
            <summary>Upper hash bits spent on storing the probes, e.g. 5 bits mean 31 probes max.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallMap4.StackEntriesCount">
            <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.New``3(System.Byte)">
            <summary>Creates the map with the <see cref="T:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3"/> storage</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4.Entry`2">
            <summary>Holds a single entry consisting of key and value. 
            Value may be set or changed but the key is set in stone (by construction).</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallMap4.Entry`2.Key">
            <summary>The readonly key</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallMap4.Entry`2.Value">
            <summary>The mutable value</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.Entry`2.#ctor(`0)">
            <summary>Construct with the key and default value</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.Entry`2.#ctor(`0,`1)">
            <summary>Construct with the key and value</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.ToB(System.Int32)">
            binary representation of the `int`
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4.IEntries`3">
            <summary>Abstraction to configure your own entries data structure. Check the derived types for the examples</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.IEntries`3.Init(System.Byte)">
            <summary>Initializes the entries storage to the specified capacity via the number of <paramref name="capacityBitShift"/> bits in the capacity</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.IEntries`3.GetSurePresentEntryRef(System.Int32)">
            <summary>Returns the reference to entry by its index, index should map to the present/non-removed entry</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.IEntries`3.AddKeyAndGetValueRef(`0,System.Int32)">
            <summary>Adds the key at the "end" of entries - so the order of addition is preserved.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4.NoValue">
            <summary>For now to use in the Set as a value</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3">
            <summary>Stores the entries in a single dynamically reallocated growing array</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3.Init(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3.GetSurePresentEntryRef(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3.AddKeyAndGetValueRef(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.TryGetValueRef``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,``0,System.Boolean@)">
            <summary>Finds the stored value by key. If found returns ref to the value it can be modified in place.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.ContainsKey``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,``0)">
            <summary>Finds the stored value by key. If found returns ref to the value it can be modified in place.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.AddOrGetValueRef``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,``0,System.Boolean@)">
            <summary>Gets the reference to the existing value of the provided key, or the default value to set for the newly added key.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.AddSureAbsentDefaultAndGetRef``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,``0)">
            <summary>Adds the sure absent key entry. 
            Provides the performance in scenarios where you look for present key, and using it, and if ABSENT then add the new one.
            So this method optimized NOT to look for the present item for the second time in SEQUENCE</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.GetSurePresentEntryRef``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,System.Int32)">
            <summary>Get the value ref by the entry index. Also the index corresponds to entry adding order.
            Important: it does not checks the index bounds, so you need to check that the index is from 0 to map.Count-1</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4`4">
            <summary>
            Fast and less-allocating hash map without thread safety nets. Please measure it in your own use case before use.
            It is configurable in regard of hash calculation/equality via `TEq` type parameter and 
            in regard of key-value storage via `TEntries` type parameter.
            
            Details:
            - Implemented as a struct so that the empty/default map does not allocate on heap
            - Hashes and key-values are the separate collections enabling better cash locality and faster performance (data-oriented design)
            - No SIMD for now to avoid complexity and costs for the smaller maps, so the map is more fit for the smaller sizes.
            - Provides the "stable" enumeration of the entries in the added order
            - The TryRemove method removes the hash but replaces the key-value entry with the tombstone key and the default value.
            For instance, for the `RefEq` the tombstone is <see langword="null"/>. You may redefine it in the `IEq{K}.GetTombstone()` implementation.
            
            </summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallMap4`4.CapacityBitShift">
            <summary>Capacity bits</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallMap4`4.PackedHashesAndIndexes">
            <summary>Access to the hashes and indexes</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallMap4`4.Count">
            <summary>Number of entries in the map</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallMap4`4.Entries">
            <summary>Access to the key-value entries</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4`4.#ctor(System.Byte)">
            <summary>Capacity calculates as `1 leftShift capacityBitShift`</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>
            Specifies that null is allowed as an input even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>
            Specifies that null is disallowed as an input even if the corresponding type allows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>
            Applied to a method that will never return under any circumstance.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>
            Specifies that the method will not return if the associated Boolean parameter is passed the specified value.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes the attribute with the specified parameter value.
            </summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable
            by diagnostics if the argument to the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>
            Gets the condition parameter value.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>
            Indicates that an API is experimental and it may change in the future.
            </summary>
            <remarks>
            This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
            feature is used. Authors can use this attribute to ship preview features in their assemblies.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class,
            specifying the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.DiagnosticId">
            <summary>
            Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <value>The unique diagnostic ID.</value>
            <remarks>
            The diagnostic ID is shown in build output for warnings and errors.
            <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.UrlFormat">
            <summary>
            Gets or sets the URL for corresponding documentation.
            The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
            </summary>
            <value>The format string that represents a URL to corresponding documentation.</value>
            <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>
            Specifies that an output may be null even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter may be null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>
            Gets the return value condition.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property members have not-null values.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes the attribute with a field or property member.
            </summary>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
            Initializes the attribute with the list of field and property members.
            </summary>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property
            members have not-null values when returning with the specified return value condition.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes the attribute with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes the attribute with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            Gets the return value condition.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>
            Specifies that an output will not be null even if the corresponding type allows it.
            Specifies that an input argument was not null when the call returns.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>
            Specifies that the output will be non-null if the named parameter is non-null.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes the attribute with the associated parameter name.
            </summary>
            <param name="parameterName">The associated parameter name. The output will be non-null if the argument to the parameter specified is non-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>
            Gets the associated parameter name.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>
            Specifies the syntax used in a string.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)">
            <summary>
            Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])">
            <summary>Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.</summary>
            <param name="syntax">The syntax identifier.</param>
            <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Syntax">
            <summary>Gets the identifier of the syntax used.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Arguments">
            <summary>Optional arguments associated with the specific syntax employed.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.CompositeFormat">
            <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateOnlyFormat">
            <summary>The syntax identifier for strings containing date format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateTimeFormat">
            <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.EnumFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Enum"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.GuidFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Guid"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Json">
            <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.NumericFormat">
            <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex">
            <summary>The syntax identifier for strings containing regular expressions.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeOnlyFormat">
            <summary>The syntax identifier for strings containing time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeSpanFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.TimeSpan"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Uri">
            <summary>The syntax identifier for strings containing URIs.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Xml">
            <summary>The syntax identifier for strings containing XML.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>
            Used to indicate a byref escapes and is not scoped.
            </summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
                <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
                <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
                <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>
            This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
            </para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute">
            <summary>
            Indicates the type of the async method builder that should be used by a language compiler to
            build the attributed async method or to build the attributed type when used as the return type
            of an async method.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.#ctor(System.Type)">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute"/>.</summary>
            <param name="builderType">The <see cref="T:System.Type"/> of the associated builder.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.BuilderType">
            <summary>Gets the <see cref="T:System.Type"/> of the associated builder.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>
            An attribute that allows parameters to receive the expression of other parameters.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.
            </summary>
            <param name="parameterName">The condition parameter value.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>
            Gets the parameter name the expression is retrieved from.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CollectionBuilderAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initialize the attribute to refer to the <paramref name="methodName"/> method on the <paramref name="builderType"/> type.
            </summary>
            <param name="builderType">The type of the builder to use to construct the collection.</param>
            <param name="methodName">The name of the method on the builder to use to construct the collection.</param>
            <remarks>
            <paramref name="methodName"/> must refer to a static method that accepts a single parameter of
            type <see cref="T:System.ReadOnlySpan`1"/> and returns an instance of the collection being built containing
            a copy of the data from that span.  In future releases of .NET, additional patterns may be supported.
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.BuilderType">
            <summary>
            Gets the type of the builder to use to construct the collection.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.MethodName">
            <summary>
            Gets the name of the method on the builder to use to construct the collection.
            </summary>
            <remarks>
            This should match the metadata name of the target method.
            For example, this might be ".ctor" if targeting the type's constructor.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> type.
            </summary>
            <param name="featureName">The name of the feature to indicate.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>
            The name of the compiler feature.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>
            Gets the names of the arguments that should be passed to the handler.
            </summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>
            Indicates the attributed type is to be used as an interpolated string handler.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
             <summary>
             Used to indicate to the compiler that a method should be called
             in its containing module's initializer.
             </summary>
             <remarks>
             When one or more valid methods
             with this attribute are found in a compilation, the compiler will
             emit a module initializer which calls each of the attributed methods.
            
             Certain requirements are imposed on any method targeted with this attribute:
             - The method must be `static`.
             - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
             - The method must be parameterless.
             - The method must return `void`.
             - The method must not be generic or be contained in a generic type.
             - The method's effective accessibility must be `internal` or `public`.
            
             The specification for module initializers in the .NET runtime can be found here:
             https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>
            Specifies that a type has required members or that a member is required.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiresLocationAttribute">
            <summary>
            Reserved for use by a compiler for tracking metadata.
            This attribute should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class with the specified message.
            </summary>
            <param name="message">An optional message associated with this attribute instance.</param>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Message">
            <summary>
            Returns the optional message associated with this attribute instance.
            </summary>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Url">
            <summary>
            Returns the optional URL associated with this attribute instance.
            </summary>
        </member>
        <member name="T:Parlot.CharToStringTable">
            <summary>
            Cache of char to string mapping to reduce allocations
            when doing chars comparisons.
            </summary>
        </member>
        <member name="T:Parlot.Compilation.CompilationContext">
            <summary>
            Represents the context of a compilation phase, coordinating all the parsers involved.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.ParseContext">
            <summary>
            Gets the expression containing the the <see cref="P:Parlot.Compilation.CompilationContext.ParseContext"/> instance for the parser.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.NextNumber">
            <summary>
            Gets or sets a counter used to generate unique variable names.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.GlobalVariables">
            <summary>
            Gets the list of global variables to add the the final list of statements.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.GlobalExpressions">
            <summary>
            Gets the list of global expressions to add the the final list of statements.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.Lambdas">
            <summary>
            Gets the list of shared lambda expressions representing intermediate parsers.
            </summary>
            <remarks>
            This is used for debug only, in order to inspect the source generated for these intermediate parsers.
            </remarks>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.DiscardResult">
            <summary>
            Gets or sets whether the current compilation phase should ignore the results of the parsers.
            </summary>
            <remarks>
            When set to false, the compiled statements don't need to record and define the <see cref="P:Parlot.Compilation.CompilationResult.Value"/> property.
            This is done to optimize compiled parser that are usually used for pattern matching only.
            </remarks>
        </member>
        <member name="M:Parlot.Compilation.CompilationContext.CreateCompilationResult``1(System.Boolean,System.Linq.Expressions.Expression)">
            <summary>
            Creates a <see cref="T:Parlot.Compilation.CompilationResult"/> instance with a <see cref="P:Parlot.Compilation.CompilationResult.Value"/> and <see cref="P:Parlot.Compilation.CompilationResult.Success"/>
            variables.
            </summary>
            <typeparam name="TValue">The type of the value returned by the parser instance.</typeparam>
            <param name="defaultSuccess">The default value of the <see cref="P:Parlot.Compilation.CompilationResult.Success"/> variable.</param>
            <param name="defaultValue">The default value of the <see cref="P:Parlot.Compilation.CompilationResult.Value"/> variable.</param>
            <returns></returns>
        </member>
        <member name="M:Parlot.Compilation.CompilationContext.CreateCompilationResult(System.Type,System.Boolean,System.Linq.Expressions.Expression)">
            <summary>
            Creates a <see cref="T:Parlot.Compilation.CompilationResult"/> instance with a <see cref="P:Parlot.Compilation.CompilationResult.Value"/> and <see cref="P:Parlot.Compilation.CompilationResult.Success"/>
            variables.
            </summary>
            <param name="valueType">The type of the value returned by the parser instance.</param>
            <param name="defaultSuccess">The default value of the <see cref="P:Parlot.Compilation.CompilationResult.Success"/> variable.</param>
            <param name="defaultValue">The default value of the <see cref="P:Parlot.Compilation.CompilationResult.Value"/> variable.</param>
            <returns></returns>
        </member>
        <member name="T:Parlot.Compilation.CompilationResult">
            <summary>
            Every parser that is compiled returns an instance of <see cref="T:Parlot.Compilation.CompilationResult"/> which encapsulates the statements to execute in order
            to parse the expected input.
            The convention is that these statements are returned in the <see cref="P:Parlot.Compilation.CompilationResult.Body"/> property, and any variable that needs to be declared in the block
            that the <see cref="P:Parlot.Compilation.CompilationResult.Body"/> is used in are set in the <see cref="P:Parlot.Compilation.CompilationResult.Variables"/> list.
            The <see cref="P:Parlot.Compilation.CompilationResult.Success"/> property represents the variable that contains the success of the statements once executed, and if <code>true</code> then 
            the <see cref="P:Parlot.Compilation.CompilationResult.Value"/> property contains the result.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationResult.Variables">
            <summary>
            Gets the list of <see cref="T:System.Linq.Expressions.ParameterExpression"/> representing the variables used by the compiled result.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationResult.Body">
            <summary>
            Gets the list of <see cref="T:System.Linq.Expressions.Expression"/> representing the body of the compiled results.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationResult.Success">
            <summary>
            Gets or sets the <see cref="T:System.Linq.Expressions.ParameterExpression"/> of the <see cref="T:System.Boolean"/> variable representing the success of the parsing statements.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationResult.Value">
            <summary>
            Gets or sets the <see cref="T:System.Linq.Expressions.ParameterExpression"/> of the <see cref="T:System.Boolean"/> variable representing the value of the parsing statements.
            </summary>
        </member>
        <member name="T:Parlot.Compilation.ICompiledParser">
            <summary>
            Marker interface to detect a Parser has already been compiled.
            </summary>
        </member>
        <member name="T:Parlot.Compilation.CompiledParser`1">
            <summary>
            An instance of this class encapsulates the result of a compiled parser
            in order to expose is as as standard parser contract.
            </summary>
            <remarks>
            This class is used in <see cref="M:Parlot.Fluent.Parser`1.Compile"/>.
            </remarks>
        </member>
        <member name="M:Parlot.Compilation.ICompilable.Compile(Parlot.Compilation.CompilationContext)">
            <summary>
            Creates a compiled representation of a parser.
            </summary>
            <param name="context">The current compilation context.</param>
        </member>
        <member name="P:Parlot.Cursor.Span">
            <summary>
            Returns the <see cref="T:System.ReadOnlySpan`1"/> value of the <see cref="P:Parlot.Cursor.Buffer" /> at the current offset.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Advance">
            <summary>
            Advances the cursor by one character.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Advance(System.Int32)">
            <summary>
            Advances the cursor.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.AdvanceNoNewLines(System.Int32)">
            <summary>
            Advances the cursor with the knowledge there are no new lines.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.ResetPosition(Parlot.TextPosition@)">
            <summary>
            Moves the cursor to the specific position
            </summary>
        </member>
        <member name="P:Parlot.Cursor.Current">
            <summary>
            Evaluates the char at the current position.
            </summary>
        </member>
        <member name="P:Parlot.Cursor.Offset">
            <summary>
            Returns the cursor's position in the _buffer.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.PeekNext(System.Int32)">
            <summary>
            Evaluates a char forward in the _buffer.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Match(System.Char)">
            <summary>
            Whether a char is at the current position.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Match(System.ReadOnlySpan{System.Char})">
            <summary>
            Whether a string is at the current position.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Match(System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Whether a string is at the current position.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Always`1">
            <summary>
            Doesn't parse anything and return the default value.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Discard`2">
            <summary>
            Doesn't parse anything and return the default value.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Else`1">
            <summary>
            Returns a default value if the previous parser failed.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Eof`1">
            <summary>
            Successful when the cursor is at the end of the string.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.NumberLiteralBase`1">
            <summary>
            This class is used as a base class for custom number parsers which don't implement INumber<typeparamref name="T"/> after .NET 7.0.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.None">
            <summary>
            Indicates that no style elements, such as leading sign, thousands
            separators, decimal separator or exponent, can be present in the parsed string.
            The string to be parsed must consist of integral decimal digits only.        
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.AllowLeadingSign">
            <summary>
            Indicates that the numeric string can have a leading sign. Valid leading sign
            characters are plus (+) and minus (-).
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.AllowDecimalSeparator">
            <summary>
            Indicates that the numeric string can have a decimal separator. By default it uses dot (.) as the separator.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.AllowGroupSeparators">
            <summary>
            Indicates that the numeric string can have group separators, such as symbols
            that separate hundreds from thousands. the default group separator is comma (,).
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.AllowExponent">
            <summary>
            Indicates that the numeric string can be in exponential notation. It
            allows the parsed string to contain an exponent that begins with the "E"
            or "e" character and that is followed by an optional positive or negative sign
            and an integer.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.Integer">
            <summary>
            Indicates that the <see cref="F:Parlot.Fluent.NumberOptions.AllowLeadingSign"/>
            style is used. This is a composite number style.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.Number">
            <summary>
            Indicates that the <see cref="F:Parlot.Fluent.NumberOptions.AllowLeadingSign"/>, <see cref="F:Parlot.Fluent.NumberOptions.AllowDecimalSeparator"/>, <see cref="F:Parlot.Fluent.NumberOptions.AllowGroupSeparators"/>
            styles are used. This is a composite number style.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.Float">
            <summary>
            Indicates that the <see cref="F:Parlot.Fluent.NumberOptions.AllowLeadingSign"/>, <see cref="F:Parlot.Fluent.NumberOptions.AllowDecimalSeparator"/>, <see cref="F:Parlot.Fluent.NumberOptions.AllowExponent"/>
            styles are used. This is a composite number style.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.Any">
            <summary>
            Indicates that all options are used.
            This is a composite number style.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.OneOf`1">
            <summary>
            OneOf the inner choices when all parsers return the same type.
            We then return the actual result of each parser.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Parlot.Fluent.ParseContext.CompilationThreshold">
            <summary>
            The number of usages of the parser before it is compiled automatically. <c>0</c> to disable automatic compilation. Default is 0.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.ParseContext.UseNewLines">
            <summary>
            Whether new lines are treated as normal chars or white spaces. Default is <c>false</c>.
            </summary>
            <remarks>
            When <c>false</c>, new lines will be skipped like any other white space.
            Otherwise new lines need to be read explicitly by a rule.
            </remarks>
        </member>
        <member name="F:Parlot.Fluent.ParseContext.Scanner">
            <summary>
            The scanner used for the parsing session.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.ParseContext.OnEnterParser">
            <summary>
            Delegate that is executed whenever a parser is invoked.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.ParseContext.WhiteSpaceParser">
            <summary>
            The parser that is used to parse whitespaces and comments.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.ParseContext.EnterParser``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Called whenever a parser is invoked. Will be used to detect invalid states and infinite loops.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Compile">
            <summary>
            Compiles the current parser.
            </summary>
            <returns>A compiled parser.</returns>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Build(Parlot.Compilation.CompilationContext,System.Boolean)">
            <summary>
            Invokes the <see cref="M:Parlot.Compilation.ICompilable.Compile(Parlot.Compilation.CompilationContext)"/> method of the <see cref="T:Parlot.Fluent.Parser`1"/> if it's available or 
            creates a generic one.
            </summary>
            <param name="context">The <see cref="T:Parlot.Compilation.CompilationContext"/> instance.</param>
            <param name="requireResult">Forces the instruction to compute the resulting value whatever the state of <see cref="P:Parlot.Compilation.CompilationContext.DiscardResult"/> is.</param>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Then``1(System.Func{`0,``0})">
            <summary>
            Builds a parser that converts the previous result when it succeeds.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Then``1(System.Func{Parlot.Fluent.ParseContext,`0,``0})">
            <summary>
            Builds a parser that converts the previous result, and can alter the current <see cref="T:Parlot.Fluent.ParseContext"/>.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Then``1(``0)">
            <summary>
            Builds a parser that converts the previous result.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.ThenElse``1(System.Func{`0,``0},``0)">
            <summary>
            Builds a parser that converts the previous result when it succeeds or returns a default value if it fails.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.ThenElse``1(System.Func{Parlot.Fluent.ParseContext,`0,``0},``0)">
            <summary>
            Builds a parser that converts the previous result or returns a default value if it fails, and can alter the current <see cref="T:Parlot.Fluent.ParseContext"/>.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.ThenElse``1(``0,``0)">
            <summary>
            Builds a parser that converts the previous result or returns a default value if it fails.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.ElseError(System.String)">
            <summary>
            Builds a parser that emits an error when the previous parser failed.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Error(System.String)">
            <summary>
            Builds a parser that emits an error.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Error``1(System.String)">
            <summary>
            Builds a parser that emits an error.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.When(System.Func{`0,System.Boolean})">
            <summary>
            Builds a parser that verifies the previous parser result matches a predicate.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Switch``1(System.Func{Parlot.Fluent.ParseContext,`0,Parlot.Fluent.Parser{``0}})">
            <summary>
            Builds a parser what returns another one based on the previous result.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Eof">
            <summary>
            Builds a parser that ensures the cursor is at the end of the input.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Discard``1">
            <summary>
            Builds a parser that discards the previous result and replaces it by the specified type or value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Discard``1(``0)">
            <summary>
            Builds a parser that discards the previous result and replaces it by the specified type or value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Else(`0)">
            <summary>
            Builds a parser that returns a default value if the previous parser fails.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``2(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``3(Parlot.Fluent.Sequence{``0,``1},Parlot.Fluent.Parser{``2})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``4(Parlot.Fluent.Sequence{``0,``1,``2},Parlot.Fluent.Parser{``3})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``5(Parlot.Fluent.Sequence{``0,``1,``2,``3},Parlot.Fluent.Parser{``4})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``6(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4},Parlot.Fluent.Parser{``5})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``7(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5},Parlot.Fluent.Parser{``6})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``2(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``3(Parlot.Fluent.Sequence{``0,``1},Parlot.Fluent.Parser{``2})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``4(Parlot.Fluent.Sequence{``0,``1,``2},Parlot.Fluent.Parser{``3})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``5(Parlot.Fluent.Sequence{``0,``1,``2,``3},Parlot.Fluent.Parser{``4})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``6(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4},Parlot.Fluent.Parser{``5})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``7(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5},Parlot.Fluent.Parser{``6})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``8(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5,``6},Parlot.Fluent.Parser{``7})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.Parsers.Literals">
            <summary>
            Provides parsers for literals. Literals do not skip spaces before being parsed and can be combined to
            parse composite terms.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.Parsers.Terms">
            <summary>
            Provides parsers for terms. Terms skip spaces before being parsed.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Separated``2(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that looks for zero or many times a parser separated by another one.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipWhiteSpace``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that skips white spaces before another one.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.ZeroOrOne``1(Parlot.Fluent.Parser{``0},``0)">
            <summary>
            Builds a parser that looks for zero or one time the specified parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.ZeroOrOne``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that looks for zero or one time the specified parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.ZeroOrMany``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that looks for zero or many times the specified parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.OneOrMany``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that looks for one or many times the specified parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Not``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that succeeds when the specified parser fails to match.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Deferred``1">
            <summary>
            Builds a parser that can be defined later one. Use it when a parser need to be declared before its rule can be set.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Recursive``1(System.Func{Parlot.Fluent.Deferred{``0},Parlot.Fluent.Parser{``0}})">
            <summary>
            Builds a parser than needs a reference to itself to be declared.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Between``3(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1},Parlot.Fluent.Parser{``2})">
            <summary>
            Builds a parser that matches the specified parser between two other ones.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AnyCharBefore``1(Parlot.Fluent.Parser{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Builds a parser that matches any chars before a specific parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Capture``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that captures the output of another parser.
            This is used to provide pattern matching capabilities, and optimized compiled parsers that then don't need to materialize each parser result.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Always">
            <summary>
            Builds a parser that always succeeds.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Always``1">
            <summary>
            Builds a parser that always succeeds.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Always``1(``0)">
            <summary>
            Builds a parser that always succeeds.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Or``1(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that return either of the first successful of the specified parsers.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Or``3(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that return either of the first successful of the specified parsers.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.OneOf``1(Parlot.Fluent.Parser{``0}[])">
            <summary>
            Builds a parser that return either of the first successful of the specified parsers.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``2(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``3(Parlot.Fluent.Sequence{``0,``1},Parlot.Fluent.Parser{``2})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``4(Parlot.Fluent.Sequence{``0,``1,``2},Parlot.Fluent.Parser{``3})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``5(Parlot.Fluent.Sequence{``0,``1,``2,``3},Parlot.Fluent.Parser{``4})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``6(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4},Parlot.Fluent.Parser{``5})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``7(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5},Parlot.Fluent.Parser{``6})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``8(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5,``6},Parlot.Fluent.Parser{``7})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.LeftAssociative``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{``0,``0,``0}}[])">
            <summary>
            Builds a parser that creates a left-associative structure.
            c.f. https://en.wikipedia.org/wiki/Operator_associativity
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
            <example>
            // additive => multiplicative(("-" | "+") multiplicative) * ;
            var additive = multiplicative.LeftAssociative(
                (plus, static (a, b) => new Addition(a, b)),
                (minus, static (a, b) => new Subtraction(a, b))
                );
            </example>
        </member>
        <member name="M:Parlot.Fluent.Parsers.LeftAssociative``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{Parlot.Fluent.ParseContext,``0,``0,``0}}[])">
            <summary>
            Builds a parser that creates a left-associative structure.
            c.f. https://en.wikipedia.org/wiki/Operator_associativity
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
            <example>
            // additive => multiplicative(("-" | "+") multiplicative) * ;
            var additive = multiplicative.LeftAssociative(
                (plus, static (a, b) => new Addition(a, b)),
                (minus, static (a, b) => new Subtraction(a, b))
                );
            </example>
        </member>
        <member name="M:Parlot.Fluent.Parsers.RightAssociative``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{``0,``0,``0}}[])">
            <summary>
            Builds a parser that creates a right-associative structure.
            c.f. https://en.wikipedia.org/wiki/Operator_associativity
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
            <example>
            // exponentiation => primary( ("^") primary) * ;
            var exponentiation = primary.RightAssociative(
                (equal, static (a, b) => new Exponent(a, b))
                );
            </example>
        </member>
        <member name="M:Parlot.Fluent.Parsers.RightAssociative``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{Parlot.Fluent.ParseContext,``0,``0,``0}}[])">
            <summary>
            Builds a parser that creates a right-associative structure.
            c.f. https://en.wikipedia.org/wiki/Operator_associativity
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
            <example>
            // exponentiation => primary( ("^") primary) * ;
            var exponentiation = primary.RightAssociative(
                (equal, static (a, b) => new Exponent(a, b))
                );
            </example>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Unary``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{``0,``0}}[])">
            <summary>
            Builds a parser that creates a unary operation.
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Unary``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{Parlot.Fluent.ParseContext,``0,``0}}[])">
            <summary>
            Builds a parser that creates a unary operation.
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.WhiteSpace(System.Boolean)">
            <summary>
            Builds a parser that matches whitespaces.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.NonWhiteSpace(System.Boolean)">
            <summary>
            Builds a parser that matches anything until whitespaces.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Text(System.String,System.Boolean)">
            <summary>
            Builds a parser that matches the specified text.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Char(System.Char)">
            <summary>
            Builds a parser that matches the specified char.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Number``1(Parlot.Fluent.NumberOptions,System.Char,System.Char)">
            <summary>
            Builds a parser that matches a number and returns any numeric type.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Integer(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches an integer with an option leading sign.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Decimal(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Decimal"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Float(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Single"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Double(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Double"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.String(Parlot.Fluent.StringLiteralQuotes)">
            <summary>
            Builds a parser that matches an quoted string that can be escaped.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Identifier(System.Func{System.Char,System.Boolean},System.Func{System.Char,System.Boolean})">
            <summary>
            Builds a parser that matches an identifier.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Pattern(System.Func{System.Char,System.Boolean},System.Int32,System.Int32)">
            <summary>
            Builds a parser that matches a char against a predicate.
            </summary>
            <param name="predicate">The predicate to match against each char.</param>
            <param name="minSize">The minimum number of matches required. Defaults to 1.</param>
            <param name="maxSize">When the parser reaches the maximum number of matches it returns <see langword="True"/>. Defaults to 0, i.e. no maximum size.</param>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.NonWhiteSpace(System.Boolean)">
            <summary>
            Builds a parser that matches anything until whitespaces.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Text(System.String,System.Boolean)">
            <summary>
            Builds a parser that matches the specified text.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Char(System.Char)">
            <summary>
            Builds a parser that matches the specified char.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Number``1(Parlot.Fluent.NumberOptions,System.Char,System.Char)">
            <summary>
            Builds a parser that matches a number and returns any numeric type.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Integer(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches an integer with an option leading sign.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Decimal(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Decimal"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Float(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Single"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Double(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Double"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.String(Parlot.Fluent.StringLiteralQuotes)">
            <summary>
            Builds a parser that matches an quoted string that can be escaped.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Identifier(System.Func{System.Char,System.Boolean},System.Func{System.Char,System.Boolean})">
            <summary>
            Builds a parser that matches an identifier.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Pattern(System.Func{System.Char,System.Boolean},System.Int32,System.Int32)">
            <summary>
            Builds a parser that matches a char against a predicate.
            </summary>
            <param name="predicate">The predicate to match against each char.</param>
            <param name="minSize">The minimum number of matches required. Defaults to 1.</param>
            <param name="maxSize">When the parser reaches the maximum number of matches it returns <see langword="True"/>. Defaults to 0, i.e. no maximum size.</param>
        </member>
        <member name="T:Parlot.Fluent.Switch`2">
            <summary>
            Routes the parsing based on a custom delegate.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Then`2">
            <summary>
            Returns a new <see cref="T:Parlot.Fluent.Parser`1" /> converting the input value of 
            type T to the output value of type U using a custom function.
            </summary>
            <typeparam name="T">The input parser type.</typeparam>
            <typeparam name="U">The output parser type.</typeparam>
        </member>
        <member name="T:Parlot.Fluent.When`1">
            <summary>
            Ensure the given parser is valid based on a condition, and backtracks if not.
            </summary>
            <typeparam name="T">The output parser type.</typeparam>
        </member>
        <member name="T:Parlot.Rewriting.IRewritable`1">
            <summary>
            A Parser implementing this interface can be rewritten in a more optimized way.
            The result will replace the instance.
            </summary>
        </member>
        <member name="M:Parlot.Rewriting.IRewritable`1.Rewrite">
            <summary>
            Returns the parser to substitute.
            </summary>
        </member>
        <member name="T:Parlot.Rewriting.ISeekable">
            <summary>
            A Parser implementing this interface can only be triggered if the next char matches the one provided.
            It is used to create char lookups to optimize which Parsers need to be invoked next.
            </summary>
        </member>
        <member name="P:Parlot.Rewriting.ISeekable.CanSeek">
            <summary>
            Gets whether the current parser can be selected from a single char.
            This could vary based on the subsequent parsers.
            </summary>
        </member>
        <member name="P:Parlot.Rewriting.ISeekable.ExpectedChars">
            <summary>
            Gets the chars that can be matched next to evaluate this Parser.
            </summary>
        </member>
        <member name="P:Parlot.Rewriting.ISeekable.SkipWhitespace">
            <summary>
            Gets whether the current parser needs to skip whitespaces before being invoked.
            </summary>
        </member>
        <member name="T:Parlot.Scanner">
            <summary>
            This class is used to return tokens extracted from the input buffer.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.#ctor(System.String)">
            <summary>
            Scans some text.
            </summary>
            <param name="buffer">The string containing the text to scan.</param>
        </member>
        <member name="M:Parlot.Scanner.SkipWhiteSpaceOrNewLine">
            <summary>
            Reads any whitespace without generating a token.
            </summary>
            <returns>Whether some white space was read.</returns>
        </member>
        <member name="M:Parlot.Scanner.ReadWhile(System.Func{System.Char,System.Boolean})">
            <summary>
            Reads a token while the specific predicate is valid.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadWhile(System.Func{System.Char,System.Boolean},System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads a token while the specific predicate is valid.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadChar(System.Char)">
            <summary>
            Reads the specified text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadChar(System.Char,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specified text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadText(System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Reads the specific expected text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadText(System.ReadOnlySpan{System.Char},System.StringComparison,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specific expected text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadAnyOf(System.ReadOnlySpan{System.Char},System.StringComparison,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specific expected chars.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadAnyOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specific expected chars.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadText(System.ReadOnlySpan{System.Char})">
            <summary>
            Reads the specific expected text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadText(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specific expected text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadQuotedString(System.Char,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads a string token enclosed in single or double quotes.
            </summary>
            <remarks>
            This method doesn't escape the string, but only validates its content is syntactically correct.
            The resulting Span contains the original quotes.
            </remarks>
        </member>
        <member name="T:Parlot.TextPosition">
            <summary>
            Represents a position in a text buffer.
            </summary>
        </member>
        <member name="P:HexConverter.CharToHexLookup">
            <summary>Map from an ASCII char to its hex value, e.g. arr['b'] == 11. 0xFF means it's not a hex digit.</summary>
        </member>
    </members>
</doc>
